<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ïû•ÎπÑ ÏàòÏßë Î°úÍ∑∏ÎùºÏù¥ÌÅ¨</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.70.0/dist/phaser.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #1a1a2e;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: Arial, sans-serif;
        }

        #game-container {
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.5);
        }
    </style>
</head>
<body>
    <div id="game-container"></div>
    
    <script>
        // ========================================
        // Í≤åÏûÑ Îç∞Ïù¥ÌÑ∞ & ÏÑ§Ï†ï
        // ========================================

        // ÏïÑÏù¥ÌÖú Îì±Í∏âÎ≥Ñ Ïä§ÌÉØ
        const ITEM_STATS = {
            sword: [
                { tier: 1, power: 10, color: 0x9b59b6, name: 'ÏùºÎ∞ò' },      // Î≥¥ÎùºÏÉâ
                { tier: 2, power: 20, color: 0x3498db, name: 'Ìù¨Í∑Ä' },      // ÎÇ®ÏÉâ
                { tier: 3, power: 40, color: 0x2980b9, name: 'Î†àÏñ¥' },      // ÌååÎûÄÏÉâ
                { tier: 4, power: 80, color: 0x2ecc71, name: 'ÏóêÌîΩ' },      // Ï¥àÎ°ùÏÉâ
                { tier: 5, power: 160, color: 0x1abc9c, name: 'Ï†ÑÏÑ§' },     // Ïó∞ÎëêÏÉâ
            ]
        };

        // Í≤åÏûÑ Îç∞Ïù¥ÌÑ∞ Ï†ÄÏû•ÏÜå
        let gameData = {
            inventory: [],
            equipped: {
                sword: null
            },
            highestWave: 0,
            showController: true  // Ïª®Ìä∏Î°§Îü¨ ÌëúÏãú Ïó¨Î∂Ä
        };

        // LocalStorageÏóêÏÑú Îç∞Ïù¥ÌÑ∞ Î°úÎìú
        function loadGameData() {
            const saved = localStorage.getItem('roguelikeGameData');
            if (saved) {
                try {
                    gameData = JSON.parse(saved);
                    // Ïª®Ìä∏Î°§Îü¨ ÏÑ§Ï†ïÏù¥ ÏóÜÏúºÎ©¥ Í∏∞Î≥∏Í∞í ÏÑ§Ï†ï
                    if (gameData.showController === undefined) {
                        gameData.showController = true;
                    }
                } catch (e) {
                    console.log('Îç∞Ïù¥ÌÑ∞ Î°úÎìú Ïã§Ìå®, Ï¥àÍ∏∞ÌôîÌï©ÎãàÎã§');
                }
            }
        }

        // LocalStorageÏóê Îç∞Ïù¥ÌÑ∞ Ï†ÄÏû•
        function saveGameData() {
            localStorage.setItem('roguelikeGameData', JSON.stringify(gameData));
        }

        // Ï¥àÍ∏∞ Î°úÎìú
        loadGameData();

        // ========================================
        // Î©îÏù∏ ÌôîÎ©¥ Scene
        // ========================================

        class MainScene extends Phaser.Scene {
            constructor() {
                super({ key: 'MainScene' });
            }

            create() {
                // Î∞∞Í≤Ω
                this.add.rectangle(600, 400, 1200, 800, 0x0f0f1e);
                
                // Ï†úÎ™©
                this.add.text(600, 80, '‚öîÔ∏è Ïû•ÎπÑ ÏàòÏßë Î°úÍ∑∏ÎùºÏù¥ÌÅ¨ ‚öîÔ∏è', {
                    fontSize: '36px',
                    fill: '#fff',
                    fontStyle: 'bold'
                }).setOrigin(0.5);

                // Ï∫êÎ¶≠ÌÑ∞ ÌëúÏãú
                this.add.text(600, 200, 'üë§ ÎÇ¥ Ï∫êÎ¶≠ÌÑ∞', {
                    fontSize: '24px',
                    fill: '#fff'
                }).setOrigin(0.5);

                this.add.circle(600, 270, 30, 0x00aaff);
                
                // Ïû•Ï∞© ÏïÑÏù¥ÌÖú ÌëúÏãú
                this.showEquippedItems();

                // Ïä§ÌÉØ ÌëúÏãú
                this.showStats();

                // Î≤ÑÌäºÎì§
                this.createButtons();

                // ÏµúÍ≥† Ïõ®Ïù¥Î∏å ÌëúÏãú
                this.add.text(600, 700, `ÏµúÍ≥† Í∏∞Î°ù: Wave ${gameData.highestWave}`, {
                    fontSize: '18px',
                    fill: '#ffaa00'
                }).setOrigin(0.5);

                // Ïª®Ìä∏Î°§Îü¨ ÏÑ§Ï†ï Î≤ÑÌäº
                this.createControllerToggle();
            }

            createButtons() {
                // Í≤åÏûÑ ÏãúÏûë Î≤ÑÌäº
                const playBtn = this.add.rectangle(600, 550, 250, 60, 0x00ff00)
                    .setInteractive({ useHandCursor: true });
                this.add.text(600, 550, 'Í≤åÏûÑ ÏãúÏûë', {
                    fontSize: '28px',
                    fill: '#000'
                }).setOrigin(0.5);
                
                playBtn.on('pointerdown', () => {
                    this.scene.start('PlayScene');
                });

                // Ïù∏Î≤§ÌÜ†Î¶¨ Î≤ÑÌäº
                const inventoryBtn = this.add.rectangle(300, 550, 200, 50, 0x0088ff)
                    .setInteractive({ useHandCursor: true });
                this.add.text(300, 550, 'Ïù∏Î≤§ÌÜ†Î¶¨', {
                    fontSize: '24px',
                    fill: '#fff'
                }).setOrigin(0.5);

                inventoryBtn.on('pointerdown', () => {
                    this.openInventory();
                });

                // Ìï©ÏÑ± Î≤ÑÌäº
                const synthesisBtn = this.add.rectangle(900, 550, 200, 50, 0xff00ff)
                    .setInteractive({ useHandCursor: true });
                this.add.text(900, 550, 'Ìï©ÏÑ±', {
                    fontSize: '24px',
                    fill: '#fff'
                }).setOrigin(0.5);

                synthesisBtn.on('pointerdown', () => {
                    this.openSynthesis();
                });
            }

            createControllerToggle() {
                const toggleBtn = this.add.rectangle(600, 630, 250, 40, gameData.showController ? 0x00ff00 : 0xff0000)
                    .setInteractive({ useHandCursor: true });
                
                const toggleText = this.add.text(600, 630, 
                    `Î™®Î∞îÏùº Ïª®Ìä∏Î°§Îü¨: ${gameData.showController ? 'ON' : 'OFF'}`, {
                    fontSize: '18px',
                    fill: '#fff'
                }).setOrigin(0.5);

                toggleBtn.on('pointerdown', () => {
                    gameData.showController = !gameData.showController;
                    saveGameData();
                    toggleBtn.setFillStyle(gameData.showController ? 0x00ff00 : 0xff0000);
                    toggleText.setText(`Î™®Î∞îÏùº Ïª®Ìä∏Î°§Îü¨: ${gameData.showController ? 'ON' : 'OFF'}`);
                });
            }

            showEquippedItems() {
                let y = 330;
                
                // ÏπºÎßå ÌëúÏãú
                const sword = gameData.equipped.sword;
                const swordText = sword ? ITEM_STATS.sword[sword - 1].name : 'ÏóÜÏùå';
                const swordColor = sword ? '#' + ITEM_STATS.sword[sword - 1].color.toString(16).padStart(6, '0') : '#888888';
                this.add.text(600, y, `‚öîÔ∏è ${swordText}`, {
                    fontSize: '18px',
                    fill: swordColor
                }).setOrigin(0.5);
            }

            showStats() {
                const stats = this.calculateStats();
                this.add.text(600, 380, `Í≥µÍ≤©Î†•: ${stats.power}`, {
                    fontSize: '20px',
                    fill: '#ffff00'
                }).setOrigin(0.5);
            }

            calculateStats() {
                let power = 10; // Í∏∞Î≥∏ Í≥µÍ≤©Î†•

                if (gameData.equipped.sword) {
                    power += ITEM_STATS.sword[gameData.equipped.sword - 1].power;
                }

                return { power };
            }

            openInventory() {
                this.add.rectangle(600, 400, 1200, 800, 0x000000, 0.8);
                this.add.rectangle(600, 400, 900, 650, 0x1a1a2e);
                
                this.add.text(600, 100, 'üì¶ Ïù∏Î≤§ÌÜ†Î¶¨', {
                    fontSize: '28px',
                    fill: '#fff'
                }).setOrigin(0.5);

                this.add.text(600, 150, 'ÏïÑÏù¥ÌÖúÏùÑ ÌÅ¥Î¶≠ÌïòÏó¨ Ïû•Ï∞©', {
                    fontSize: '16px',
                    fill: '#aaa'
                }).setOrigin(0.5);

                // ÏïÑÏù¥ÌÖú Î¨∂Í∏∞ (tierÎ≥ÑÎ°ú Í∞úÏàò Í≥ÑÏÇ∞)
                const grouped = {};
                gameData.inventory.forEach(item => {
                    const key = item.tier;
                    if (!grouped[key]) {
                        grouped[key] = [];
                    }
                    grouped[key].push(item);
                });

                // ÏïÑÏù¥ÌÖú Í∑∏Î¶¨Îìú
                let x = 250;
                let y = 220;
                const itemsPerRow = 6;
                let index = 0;

                Object.keys(grouped).forEach(tier => {
                    const items = grouped[tier];
                    const count = items.length;
                    const itemData = ITEM_STATS.sword[tier - 1];

                    const box = this.add.rectangle(x, y, 80, 80, itemData.color)
                        .setInteractive({ useHandCursor: true });

                    this.add.text(x, y - 18, '‚öîÔ∏è', {
                        fontSize: '24px'
                    }).setOrigin(0.5);

                    this.add.text(x, y + 5, itemData.name, {
                        fontSize: '14px',
                        fill: '#fff'
                    }).setOrigin(0.5);

                    this.add.text(x, y + 25, `x${count}`, {
                        fontSize: '14px',
                        fill: '#ffff00'
                    }).setOrigin(0.5);

                    // ÌÅ¥Î¶≠ Ïãú ‚Üí Í∞ôÏùÄ Ìã∞Ïñ¥ Ï§ë ÌïòÎÇòÎßå Ïû•Ï∞©
                    box.on('pointerdown', () => {
                        const realIndex = gameData.inventory.findIndex(i => i.tier == tier);
                        this.equipItem(gameData.inventory[realIndex], realIndex);
                        this.scene.restart();
                    });

                    x += 100;
                    index++;
                    if (index % itemsPerRow === 0) {
                        x = 250;
                        y += 100;
                    }
                });

                // Îã´Í∏∞ Î≤ÑÌäº
                const closeBtn = this.add.rectangle(600, 680, 150, 40, 0xff0000)
                    .setInteractive({ useHandCursor: true });
                this.add.text(600, 680, 'Îã´Í∏∞', {
                    fontSize: '20px',
                    fill: '#fff'
                }).setOrigin(0.5);

                closeBtn.on('pointerdown', () => {
                    this.scene.restart();
                });
            }

            equipItem(item, inventoryIndex) {
                if (item.type === 'sword') {
                    if (gameData.equipped.sword) {
                        gameData.inventory.push({ type: 'sword', tier: gameData.equipped.sword });
                    }
                    gameData.equipped.sword = item.tier;
                    gameData.inventory.splice(inventoryIndex, 1);
                }
                saveGameData();
            }

            openSynthesis() {
                this.add.rectangle(600, 400, 1200, 800, 0x000000, 0.8);
                this.add.rectangle(600, 400, 900, 650, 0x1a1a2e);
                
                this.add.text(600, 100, 'üîÆ ÏïÑÏù¥ÌÖú Ìï©ÏÑ±', {
                    fontSize: '28px',
                    fill: '#fff'
                }).setOrigin(0.5);

                this.add.text(600, 150, 'Í∞ôÏùÄ Ï¢ÖÎ•ò 5Í∞úÎ•º Ìï©ÏÑ±ÌïòÏó¨ ÏÉÅÏúÑ ÏïÑÏù¥ÌÖú ÌöçÎìù! (ÏÑ±Í≥µÎ•† 60%)', {
                    fontSize: '16px',
                    fill: '#aaa'
                }).setOrigin(0.5);

                // Ìï©ÏÑ± Í∞ÄÎä•Ìïú ÏïÑÏù¥ÌÖú Ï∞æÍ∏∞
                const itemCounts = {};
                gameData.inventory.forEach(item => {
                    const key = `sword_${item.tier}`;
                    itemCounts[key] = (itemCounts[key] || 0) + 1;
                });

                let y = 220;
                let hasItems = false;
                
                Object.keys(itemCounts).forEach(key => {
                    const tier = parseInt(key.split('_')[1]);
                    const count = itemCounts[key];
                    const itemData = ITEM_STATS.sword[tier - 1];

                    if (count >= 5 && tier < 5) {
                        hasItems = true;
                        const btn = this.add.rectangle(600, y, 500, 50, itemData.color)
                            .setInteractive({ useHandCursor: true });
                        
                        this.add.text(600, y, `${itemData.name} x${count} ‚Üí Ìï©ÏÑ±ÌïòÍ∏∞`, {
                            fontSize: '18px',
                            fill: '#fff'
                        }).setOrigin(0.5);

                        btn.on('pointerdown', () => {
                            this.synthesize(tier);
                        });

                        y += 60;
                    }
                });

                if (!hasItems) {
                    this.add.text(600, 350, 'Ìï©ÏÑ± Í∞ÄÎä•Ìïú ÏïÑÏù¥ÌÖúÏù¥ ÏóÜÏäµÎãàÎã§\n(Í∞ôÏùÄ Ï¢ÖÎ•ò 5Í∞ú ÌïÑÏöî)', {
                        fontSize: '20px',
                        fill: '#ff8888',
                        align: 'center'
                    }).setOrigin(0.5);
                }

                // Îã´Í∏∞ Î≤ÑÌäº
                const closeBtn = this.add.rectangle(600, 680, 150, 40, 0xff0000)
                    .setInteractive({ useHandCursor: true });
                this.add.text(600, 680, 'Îã´Í∏∞', {
                    fontSize: '20px',
                    fill: '#fff'
                }).setOrigin(0.5);

                closeBtn.on('pointerdown', () => {
                    this.scene.restart();
                });
            }

            synthesize(tier) {
                let removed = 0;
                gameData.inventory = gameData.inventory.filter(item => {
                    if (item.tier === tier && removed < 5) {
                        removed++;
                        return false;
                    }
                    return true;
                });

                if (Math.random() < 0.6) {
                    gameData.inventory.push({ type: 'sword', tier: tier + 1 });
                    alert(`‚ú® Ìï©ÏÑ± ÏÑ±Í≥µ! ${ITEM_STATS.sword[tier].name} ÌöçÎìù!`);
                } else {
                    alert('üí• Ìï©ÏÑ± Ïã§Ìå®... ÏïÑÏù¥ÌÖúÏù¥ ÏÜåÎ©∏ÌñàÏäµÎãàÎã§');
                }

                saveGameData();
                this.scene.restart();
            }
        }

        // ========================================
        // ÌîåÎ†àÏù¥ ÌôîÎ©¥ Scene
        // ========================================

        class PlayScene extends Phaser.Scene {
            constructor() {
                super({ key: 'PlayScene' });
            }

            create() {
                this.add.rectangle(600, 400, 1200, 800, 0x2a2a3e);

                const stats = this.calculateStats();
                
                this.playerMaxHp = 100;
                this.playerHp = 100;
                this.playerPower = stats.power;

                this.player = this.add.circle(600, 400, 20, 0x00aaff);
                this.physics.add.existing(this.player);
                this.player.body.setCollideWorldBounds(true);
                this.player.body.setCircle(20);
                this.player.body.setBounce(0);

                this.sword = this.add.rectangle(0, 0, 40, 10, 0xffff00);
                this.sword.visible = false;

                // Í≤Ä Ïø®Îã§Ïö¥ Ï∂îÍ∞Ä
                this.swordCooldown = 0;
                this.swordCooldownMax = 1000; // 1Ï¥à

                this.cursors = this.input.keyboard.createCursorKeys();
                this.input.on('pointerdown', (pointer) => {
                    this.swingSword(pointer.x, pointer.y);
                });

                this.wave = 1;
                this.monstersKilled = 0;
                this.monsters = this.physics.add.group();
                this.droppedItems = this.physics.add.group();

                this.waveText = this.add.text(600, 20, `Wave ${this.wave}`, {
                    fontSize: '28px',
                    fill: '#fff'
                }).setOrigin(0.5);

                this.hpText = this.add.text(20, 20, `HP: ${this.playerHp}/${this.playerMaxHp}`, {
                    fontSize: '20px',
                    fill: '#00ff00'
                });

                this.statsText = this.add.text(20, 50, `Í≥µÍ≤©Î†•: ${this.playerPower}`, {
                    fontSize: '16px',
                    fill: '#ffff00'
                });

                this.cooldownText = this.add.text(20, 80, `Ïø®Îã§Ïö¥: Ï§ÄÎπÑ`, {
                    fontSize: '16px',
                    fill: '#00ff00'
                });

                this.spawnWave();

                this.physics.add.collider(
                    this.player,
                    this.monsters,
                    this.onPlayerMonsterCollide,
                    null,
                    this
                );

                this.physics.add.overlap(
                    this.player,
                    this.droppedItems,
                    this.collectItem,
                    null,
                    this
                );

                this.physics.add.collider(this.monsters, this.monsters);

                // Î™®Î∞îÏùº Ïª®Ìä∏Î°§Îü¨ ÏÉùÏÑ±
                if (gameData.showController) {
                    this.createMobileController();
                }
            }

            createMobileController() {
                // Î∞©Ìñ• Î≤ÑÌäº
                const btnSize = 60;
                const btnPadding = 70;
                const baseX = 100;
                const baseY = 650;

                // ÏúÑ
                this.upBtn = this.add.rectangle(baseX, baseY - btnPadding, btnSize, btnSize, 0x444444, 0.7)
                    .setInteractive()
                    .setScrollFactor(0);
                this.add.text(baseX, baseY - btnPadding, '‚ñ≤', {
                    fontSize: '24px',
                    fill: '#fff'
                }).setOrigin(0.5).setScrollFactor(0);

                // ÏïÑÎûò
                this.downBtn = this.add.rectangle(baseX, baseY + btnPadding, btnSize, btnSize, 0x444444, 0.7)
                    .setInteractive()
                    .setScrollFactor(0);
                this.add.text(baseX, baseY + btnPadding, '‚ñº', {
                    fontSize: '24px',
                    fill: '#fff'
                }).setOrigin(0.5).setScrollFactor(0);

                // ÏôºÏ™Ω
                this.leftBtn = this.add.rectangle(baseX - btnPadding, baseY, btnSize, btnSize, 0x444444, 0.7)
                    .setInteractive()
                    .setScrollFactor(0);
                this.add.text(baseX - btnPadding, baseY, '‚óÄ', {
                    fontSize: '24px',
                    fill: '#fff'
                }).setOrigin(0.5).setScrollFactor(0);

                // Ïò§Î•∏Ï™Ω
                this.rightBtn = this.add.rectangle(baseX + btnPadding, baseY, btnSize, btnSize, 0x444444, 0.7)
                    .setInteractive()
                    .setScrollFactor(0);
                this.add.text(baseX + btnPadding, baseY, '‚ñ∂', {
                    fontSize: '24px',
                    fill: '#fff'
                }).setOrigin(0.5).setScrollFactor(0);

                // Í≥µÍ≤© Î≤ÑÌäº
                this.attackBtn = this.add.circle(1100, 680, 50, 0xff0000, 0.7)
                    .setInteractive()
                    .setScrollFactor(0);
                this.add.text(1100, 680, '‚öî', {
                    fontSize: '32px',
                    fill: '#fff'
                }).setOrigin(0.5).setScrollFactor(0);

                this.attackBtn.on('pointerdown', () => {
                    // ÌîåÎ†àÏù¥Ïñ¥ ÏïûÏ™ΩÏúºÎ°ú Í≥µÍ≤©
                    const angle = this.player.body.velocity.angle() || 0;
                    const targetX = this.player.x + Math.cos(angle) * 100;
                    const targetY = this.player.y + Math.sin(angle) * 100;
                    this.swingSword(targetX, targetY);
                });

                // Î∞©Ìñ• ÏûÖÎ†• ÏÉÅÌÉú
                this.mobileInput = {
                    up: false,
                    down: false,
                    left: false,
                    right: false
                };

                this.upBtn.on('pointerdown', () => { this.mobileInput.up = true; });
                this.upBtn.on('pointerup', () => { this.mobileInput.up = false; });
                this.upBtn.on('pointerout', () => { this.mobileInput.up = false; });

                this.downBtn.on('pointerdown', () => { this.mobileInput.down = true; });
                this.downBtn.on('pointerup', () => { this.mobileInput.down = false; });
                this.downBtn.on('pointerout', () => { this.mobileInput.down = false; });

                this.leftBtn.on('pointerdown', () => { this.mobileInput.left = true; });
                this.leftBtn.on('pointerup', () => { this.mobileInput.left = false; });
                this.leftBtn.on('pointerout', () => { this.mobileInput.left = false; });

                this.rightBtn.on('pointerdown', () => { this.mobileInput.right = true; });
                this.rightBtn.on('pointerup', () => { this.mobileInput.right = false; });
                this.rightBtn.on('pointerout', () => { this.mobileInput.right = false; });
            }

            calculateStats() {
                let power = 10;

                if (gameData.equipped.sword) {
                    power += ITEM_STATS.sword[gameData.equipped.sword - 1].power;
                }

                return { power };
            }

            update(time, delta) {
                const speed = 200;
                this.player.body.setVelocity(0);

                // ÌÇ§Î≥¥Îìú ÏûÖÎ†•
                if (this.cursors.left.isDown) {
                    this.player.body.setVelocityX(-speed);
                } else if (this.cursors.right.isDown) {
                    this.player.body.setVelocityX(speed);
                }

                if (this.cursors.up.isDown) {
                    this.player.body.setVelocityY(-speed);
                } else if (this.cursors.down.isDown) {
                    this.player.body.setVelocityY(speed);
                }

                // Î™®Î∞îÏùº ÏûÖÎ†•
                if (gameData.showController && this.mobileInput) {
                    if (this.mobileInput.left) {
                        this.player.body.setVelocityX(-speed);
                    } else if (this.mobileInput.right) {
                        this.player.body.setVelocityX(speed);
                    }

                    if (this.mobileInput.up) {
                        this.player.body.setVelocityY(-speed);
                    } else if (this.mobileInput.down) {
                        this.player.body.setVelocityY(speed);
                    }
                }

                // Ïø®Îã§Ïö¥ ÏóÖÎç∞Ïù¥Ìä∏
                if (this.swordCooldown > 0) {
                    this.swordCooldown -= delta;
                    const cooldownPercent = Math.ceil((this.swordCooldown / this.swordCooldownMax) * 100);
                    this.cooldownText.setText(`Ïø®Îã§Ïö¥: ${Math.max(0, cooldownPercent)}%`);
                    this.cooldownText.setColor('#ff0000');
                } else {
                    this.cooldownText.setText(`Ïø®Îã§Ïö¥: Ï§ÄÎπÑ`);
                    this.cooldownText.setColor('#00ff00');
                }

                // Î™¨Ïä§ÌÑ∞ AI: Ïñ¥Í∑∏Î°ú ÏÉÅÌÉúÏùº ÎïåÎßå Ï´ìÏïÑÍ∞ê
                this.monsters.children.entries.forEach(monster => {
                    if (monster.active && monster.aggro) {
                        this.physics.moveToObject(monster, this.player, 50 + this.wave * 5);
                    }
                    
                    if (monster.hpBar) {
                        monster.hpBar.x = monster.x;
                        monster.hpBar.y = monster.y - 25;
                    }
                });
            }

            spawnWave() {
                this.monstersKilled = 0;
                const monstersToSpawn = 5 + this.wave * 2;
                this.totalMonstersInWave = monstersToSpawn;

                for (let i = 0; i < monstersToSpawn; i++) {
                    this.time.delayedCall(i * 500, () => {
                        this.spawnMonster();
                    });
                }
            }

            spawnMonster() {
                const x = Phaser.Math.Between(50, 1150);
                const y = Phaser.Math.Between(50, 750);
                
                const monster = this.add.circle(x, y, 15, 0xff0000);
                this.physics.add.existing(monster);
                monster.body.setCircle(15);
                monster.body.setBounce(0);
                monster.body.setImmovable(false);

                monster.hp = 20 + this.wave * 10;
                monster.maxHp = monster.hp;
                monster.power = 5 + this.wave * 2;
                monster.tier = Math.min(Math.ceil(this.wave / 3), 5);
                monster.lastHitTime = 0;
                monster.aggro = false; // Ï≤òÏùåÏóêÎäî Ïñ¥Í∑∏Î°ú ÏóÜÏùå

                this.monsters.add(monster);

                monster.hpBar = this.add.rectangle(x, y - 25, 30, 4, 0x00ff00);
            }

            swingSword(targetX, targetY) {
                if (this.swordCooldown > 0) {
                    return;
                }

                this.swordCooldown = this.swordCooldownMax;

                this.sword.visible = true;
                const angle = Phaser.Math.Angle.Between(this.player.x, this.player.y, targetX, targetY);
                
                this.sword.x = this.player.x + Math.cos(angle) * 40;
                this.sword.y = this.player.y + Math.sin(angle) * 40;
                this.sword.rotation = angle;

                this.monsters.children.entries.forEach(monster => {
                    if (monster.active) {
                        const dist = Phaser.Math.Distance.Between(this.sword.x, this.sword.y, monster.x, monster.y);
                        if (dist < 40) {
                            this.damageMonster(monster);
                        }
                    }
                });

                this.time.delayedCall(100, () => {
                    this.sword.visible = false;
                });
            }

            damageMonster(monster) {
                monster.hp -= this.playerPower;
                monster.aggro = true; // Í≥µÍ≤©Î∞õÏúºÎ©¥ Ïñ¥Í∑∏Î°ú ÌôúÏÑ±Ìôî
                
                const hpPercent = monster.hp / monster.maxHp;
                monster.hpBar.width = 30 * hpPercent;
                monster.hpBar.fillColor = hpPercent > 0.5 ? 0x00ff00 : hpPercent > 0.25 ? 0xffff00 : 0xff0000;

                if (monster.hp <= 0) {
                    this.killMonster(monster);
                }
            }

            killMonster(monster) {
                // ÏïÑÏù¥ÌÖú ÎìúÎûç (100% ÌôïÎ•†)
                if (Math.random() < 0.5) {
                    this.dropItem(monster.x, monster.y, monster.tier);
                }

                if (monster.hpBar) {
                    monster.hpBar.destroy();
                }
                monster.destroy();

                this.monstersKilled++;
                
                if (this.monstersKilled >= this.totalMonstersInWave) {
                    this.wave++;
                    this.waveText.setText(`Wave ${this.wave}`);
                    
                    if (this.wave > gameData.highestWave) {
                        gameData.highestWave = this.wave;
                    }

                    this.time.delayedCall(2000, () => {
                        this.spawnWave();
                    });
                }
            }

            dropItem(x, y, tier) {
                const itemData = ITEM_STATS.sword[tier - 1];
                
                const item = this.add.rectangle(x, y, 20, 6, itemData.color);
                item.setRotation(0.785);
                this.physics.add.existing(item);
                item.body.setSize(20, 6);
                
                item.itemTier = tier;
                item.itemType = 'sword';
                
                this.tweens.add({
                    targets: item,
                    scale: { from: 1, to: 1.2 },
                    duration: 500,
                    yoyo: true,
                    repeat: -1
                });

                this.tweens.add({
                    targets: item,
                    rotation: item.rotation + Math.PI * 2,
                    duration: 2000,
                    repeat: -1
                });

                this.droppedItems.add(item);
            }

            collectItem(player, item) {
                gameData.inventory.push({ 
                    type: item.itemType, 
                    tier: item.itemTier 
                });
                
                const itemData = ITEM_STATS.sword[item.itemTier - 1];
                const text = this.add.text(item.x, item.y - 30, `+${itemData.name}`, {
                    fontSize: '18px',
                    fill: '#' + itemData.color.toString(16).padStart(6, '0'),
                    fontStyle: 'bold'
                }).setOrigin(0.5);

                this.tweens.add({
                    targets: text,
                    y: text.y - 50,
                    alpha: 0,
                    duration: 1000,
                    onComplete: () => {
                        text.destroy();
                    }
                });

                item.destroy();
            }

            onPlayerMonsterCollide(player, monster) {
                const now = this.time.now;

                if (now - monster.lastHitTime < 100) return;

                monster.lastHitTime = now;
                monster.aggro = true; // Ï∂©Îèå ÏãúÏóêÎèÑ Ïñ¥Í∑∏Î°ú ÌôúÏÑ±Ìôî
                this.hitPlayer(monster);
            }

            hitPlayer(monster) {
                const damage = monster.power;
                this.playerHp -= damage;
                this.hpText.setText(`HP: ${this.playerHp}/${this.playerMaxHp}`);
                this.hpText.setColor(this.playerHp > this.playerMaxHp * 0.3 ? '#00ff00' : '#ff0000');

                this.cameras.main.shake(100, 0.01);

                if (this.playerHp <= 0) {
                    saveGameData();
                    this.scene.start('GameOverScene', { wave: this.wave });
                }
            }
        }

        // ========================================
        // Í≤åÏûÑ Ïò§Î≤Ñ Scene
        // ========================================

        class GameOverScene extends Phaser.Scene {
            constructor() {
                super({ key: 'GameOverScene' });
            }

            init(data) {
                this.finalWave = data.wave;
            }

            create() {
                this.add.rectangle(600, 400, 1200, 800, 0x000000);

                this.add.text(600, 250, 'üíÄ Í≤åÏûÑ Ïò§Î≤Ñ üíÄ', {
                    fontSize: '56px',
                    fill: '#ff0000'
                }).setOrigin(0.5);

                this.add.text(600, 370, `ÎèÑÎã¨ Ïõ®Ïù¥Î∏å: ${this.finalWave}`, {
                    fontSize: '28px',
                    fill: '#fff'
                }).setOrigin(0.5);

                this.add.text(600, 430, `ÌöçÎìù ÏïÑÏù¥ÌÖú: ${gameData.inventory.length}Í∞ú`, {
                    fontSize: '24px',
                    fill: '#ffaa00'
                }).setOrigin(0.5);

                const btn = this.add.rectangle(600, 530, 300, 70, 0x00ff00)
                    .setInteractive({ useHandCursor: true });
                
                this.add.text(600, 530, 'Î©îÏù∏ ÌôîÎ©¥ÏúºÎ°ú', {
                    fontSize: '28px',
                    fill: '#000'
                }).setOrigin(0.5);

                btn.on('pointerdown', () => {
                    this.scene.start('MainScene');
                });
            }
        }

        // ========================================
        // Phaser Í≤åÏûÑ ÏÑ§Ï†ï
        // ========================================

        const config = {
            type: Phaser.AUTO,
            width: 1200,
            height: 800,
            parent: 'game-container',
            physics: {
                default: 'arcade',
                arcade: {
                    gravity: { y: 0 },
                    debug: false
                }
            },
            scene: [MainScene, PlayScene, GameOverScene]
        };

        const game = new Phaser.Game(config);
    </script>
</body>
</html>