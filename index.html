<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>í˜„ë¹ˆì´ ë•Œë¦¬ê¸° ê²Œì„</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.70.0/dist/phaser.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #1a1a2e;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: Arial, sans-serif;
        }

        #game-container {
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.5);
        }
    </style>
</head>
<body>
    <div id="game-container"></div>
    
    <script>
        // ========================================
        // ê²Œì„ ë°ì´í„° & ì„¤ì •
        // ========================================

        // ì•„ì´í…œ ë“±ê¸‰ë³„ ìŠ¤íƒ¯
        const ITEM_STATS = {
            sword: [
                { tier: 1, power: 10, color: 0x9b59b6, name: 'ì¼ë°˜' },      // ë³´ë¼ìƒ‰
                { tier: 2, power: 20, color: 0x3498db, name: 'í¬ê·€' },      // ë‚¨ìƒ‰
                { tier: 3, power: 40, color: 0x2980b9, name: 'ë ˆì–´' },      // íŒŒë€ìƒ‰
                { tier: 4, power: 80, color: 0x2ecc71, name: 'ì—í”½' },      // ì´ˆë¡ìƒ‰
                { tier: 5, power: 160, color: 0x1abc9c, name: 'ì „ì„¤' },     // ì—°ë‘ìƒ‰
            ]
        };

        // ëª¬ìŠ¤í„° ë“±ê¸‰ë³„ ìŠ¤íƒ¯
        const MONSTER_STATS = [
            { tier: 1, hp: 30, power: 10, color: 0x9b59b6, name: 'ì¼ë°˜' },      // ë³´ë¼ìƒ‰
            { tier: 2, hp: 150, power: 30, color: 0x3498db, name: 'í¬ê·€' },     // ë‚¨ìƒ‰
            { tier: 3, hp: 540, power: 90, color: 0x2980b9, name: 'ë ˆì–´' },     // íŒŒë€ìƒ‰
            { tier: 4, hp: 1890, power: 270, color: 0x2ecc71, name: 'ì—í”½' },   // ì´ˆë¡ìƒ‰
            { tier: 5, hp: 6480, power: 810, color: 0x1abc9c, name: 'ì „ì„¤' },   // ì—°ë‘ìƒ‰
        ];

        // ê²Œì„ ë°ì´í„° ì €ì¥ì†Œ
        let gameData = {
            inventory: [],
            equipped: {
                sword: null
            },
            highestWave: 0,
            showController: false  // ì»¨íŠ¸ë¡¤ëŸ¬ í‘œì‹œ ì—¬ë¶€ (ê¸°ë³¸ê°’ false)
        };

        // LocalStorageì—ì„œ ë°ì´í„° ë¡œë“œ
        function loadGameData() {
            const saved = localStorage.getItem('roguelikeGameData');
            if (saved) {
                try {
                    gameData = JSON.parse(saved);
                    // ì»¨íŠ¸ë¡¤ëŸ¬ ì„¤ì •ì´ ì—†ìœ¼ë©´ ê¸°ë³¸ê°’ ì„¤ì •
                    if (gameData.showController === undefined) {
                        gameData.showController = false;
                    }
                } catch (e) {
                    console.log('ë°ì´í„° ë¡œë“œ ì‹¤íŒ¨, ì´ˆê¸°í™”í•©ë‹ˆë‹¤');
                }
            }
        }

        // LocalStorageì— ë°ì´í„° ì €ì¥
        function saveGameData() {
            localStorage.setItem('roguelikeGameData', JSON.stringify(gameData));
        }

        // ì´ˆê¸° ë¡œë“œ
        loadGameData();

        // ========================================
        // ë©”ì¸ í™”ë©´ Scene
        // ========================================

        class MainScene extends Phaser.Scene {
            constructor() {
                super({ key: 'MainScene' });
            }

            create() {
                // ë°°ê²½
                this.add.rectangle(600, 400, 1200, 800, 0x0f0f1e);
                
                // ì œëª©
                this.add.text(600, 100, 'âš”ï¸ í˜„ë¹ˆì´ ë•Œë¦¬ê¸° ê²Œì„ âš”ï¸', {
                    fontSize: '36px',
                    fill: '#fff',
                    fontStyle: 'bold'
                }).setOrigin(0.5);

                // ìºë¦­í„° í‘œì‹œ
                this.add.text(600, 220, 'ğŸ‘¤ ë‚´ ìºë¦­í„°', {
                    fontSize: '24px',
                    fill: '#fff',
                    padding: { top: 6 }
                }).setOrigin(0.5);

                this.add.circle(600, 290, 30, 0x00aaff);
                
                // ì¥ì°© ì•„ì´í…œ í‘œì‹œ
                this.showEquippedItems();

                // ìŠ¤íƒ¯ í‘œì‹œ
                this.showStats();

                // ë²„íŠ¼ë“¤
                this.createButtons();

                // ìµœê³  ì›¨ì´ë¸Œ í‘œì‹œ
                this.add.text(600, 720, `ìµœê³  ê¸°ë¡: Wave ${gameData.highestWave}`, {
                    fontSize: '18px',
                    fill: '#ffaa00'
                }).setOrigin(0.5);

                // ì»¨íŠ¸ë¡¤ëŸ¬ ì„¤ì • ë²„íŠ¼
                this.createControllerToggle();
            }

            createButtons() {
                // ê²Œì„ ì‹œì‘ ë²„íŠ¼
                const playBtn = this.add.rectangle(600, 520, 250, 60, 0x00ff00)
                    .setInteractive({ useHandCursor: true });
                this.add.text(600, 520, 'ê²Œì„ ì‹œì‘', {
                    fontSize: '28px',
                    fill: '#000'
                }).setOrigin(0.5);
                
                playBtn.on('pointerdown', () => {
                    this.scene.start('PlayScene');
                });

                // ì¸ë²¤í† ë¦¬ ë²„íŠ¼
                const inventoryBtn = this.add.rectangle(300, 520, 200, 50, 0x0088ff)
                    .setInteractive({ useHandCursor: true });
                this.add.text(300, 520, 'ì¸ë²¤í† ë¦¬', {
                    fontSize: '24px',
                    fill: '#fff'
                }).setOrigin(0.5);

                inventoryBtn.on('pointerdown', () => {
                    this.openInventory();
                });

                // í•©ì„± ë²„íŠ¼
                const synthesisBtn = this.add.rectangle(900, 520, 200, 50, 0xff00ff)
                    .setInteractive({ useHandCursor: true });
                this.add.text(900, 520, 'í•©ì„±', {
                    fontSize: '24px',
                    fill: '#fff'
                }).setOrigin(0.5);

                synthesisBtn.on('pointerdown', () => {
                    this.openSynthesis();
                });
            }

            createControllerToggle() {
                const toggleBtn = this.add.rectangle(600, 620, 250, 40, gameData.showController ? 0x00ff00 : 0xff0000)
                    .setInteractive({ useHandCursor: true });
                
                const toggleText = this.add.text(600, 620, 
                    `ëª¨ë°”ì¼ ì»¨íŠ¸ë¡¤ëŸ¬: ${gameData.showController ? 'ON' : 'OFF'}`, {
                    fontSize: '18px',
                    fill: '#fff'
                }).setOrigin(0.5);

                toggleBtn.on('pointerdown', () => {
                    gameData.showController = !gameData.showController;
                    saveGameData();
                    toggleBtn.setFillStyle(gameData.showController ? 0x00ff00 : 0xff0000);
                    toggleText.setText(`ëª¨ë°”ì¼ ì»¨íŠ¸ë¡¤ëŸ¬: ${gameData.showController ? 'ON' : 'OFF'}`);
                });
            }

            showEquippedItems() {
                let y = 350;
                
                // ì¹¼ë§Œ í‘œì‹œ
                const sword = gameData.equipped.sword;
                const swordText = sword ? ITEM_STATS.sword[sword - 1].name : 'ì—†ìŒ';
                const swordColor = sword ? '#' + ITEM_STATS.sword[sword - 1].color.toString(16).padStart(6, '0') : '#888888';
                this.add.text(600, y, `âš”ï¸ ${swordText}`, {
                    fontSize: '18px',
                    fill: swordColor
                }).setOrigin(0.5);
            }

            showStats() {
                const stats = this.calculateStats();
                this.add.text(600, 400, `ê³µê²©ë ¥: ${stats.power}`, {
                    fontSize: '20px',
                    fill: '#ffff00',
                    padding: { top: 5 }
                }).setOrigin(0.5);
            }

            calculateStats() {
                let power = 10; // ê¸°ë³¸ ê³µê²©ë ¥

                if (gameData.equipped.sword) {
                    power += ITEM_STATS.sword[gameData.equipped.sword - 1].power;
                }

                return { power };
            }

            openInventory() {
                this.add.rectangle(600, 400, 1200, 800, 0x000000, 0.8);
                this.add.rectangle(600, 400, 900, 650, 0x1a1a2e);
                
                this.add.text(600, 100, 'ğŸ“¦ ì¸ë²¤í† ë¦¬', {
                    fontSize: '28px',
                    fill: '#fff',
                    padding: { top: 7 }
                }).setOrigin(0.5);

                this.add.text(600, 150, 'ì•„ì´í…œì„ í´ë¦­í•˜ì—¬ ì¥ì°©', {
                    fontSize: '16px',
                    fill: '#aaa',
                    padding: { top: 4 }
                }).setOrigin(0.5);

                // ì•„ì´í…œ ë¬¶ê¸° (tierë³„ë¡œ ê°œìˆ˜ ê³„ì‚°)
                const grouped = {};
                gameData.inventory.forEach(item => {
                    const key = item.tier;
                    if (!grouped[key]) {
                        grouped[key] = [];
                    }
                    grouped[key].push(item);
                });

                // ì•„ì´í…œ ê·¸ë¦¬ë“œ
                let x = 250;
                let y = 220;
                const itemsPerRow = 6;
                let index = 0;

                Object.keys(grouped).forEach(tier => {
                    const items = grouped[tier];
                    const count = items.length;
                    const itemData = ITEM_STATS.sword[tier - 1];

                    const box = this.add.rectangle(x, y, 80, 80, itemData.color)
                        .setInteractive({ useHandCursor: true });

                    this.add.text(x, y - 18, 'âš”ï¸', {
                        fontSize: '24px'
                    }).setOrigin(0.5);

                    this.add.text(x, y + 5, itemData.name, {
                        fontSize: '14px',
                        fill: '#fff'
                    }).setOrigin(0.5);

                    this.add.text(x, y + 25, `x${count}`, {
                        fontSize: '14px',
                        fill: '#ffff00'
                    }).setOrigin(0.5);

                    // í´ë¦­ ì‹œ â†’ ê°™ì€ í‹°ì–´ ì¤‘ í•˜ë‚˜ë§Œ ì¥ì°©
                    box.on('pointerdown', () => {
                        const realIndex = gameData.inventory.findIndex(i => i.tier == tier);
                        this.equipItem(gameData.inventory[realIndex], realIndex);
                        this.scene.restart();
                    });

                    x += 100;
                    index++;
                    if (index % itemsPerRow === 0) {
                        x = 250;
                        y += 100;
                    }
                });

                // ë‹«ê¸° ë²„íŠ¼
                const closeBtn = this.add.rectangle(600, 680, 150, 40, 0xff0000)
                    .setInteractive({ useHandCursor: true });
                this.add.text(600, 680, 'ë‹«ê¸°', {
                    fontSize: '20px',
                    fill: '#fff'
                }).setOrigin(0.5);

                closeBtn.on('pointerdown', () => {
                    this.scene.restart();
                });
            }

            equipItem(item, inventoryIndex) {
                if (item.type === 'sword') {
                    if (gameData.equipped.sword) {
                        gameData.inventory.push({ type: 'sword', tier: gameData.equipped.sword });
                    }
                    gameData.equipped.sword = item.tier;
                    gameData.inventory.splice(inventoryIndex, 1);
                }
                saveGameData();
            }

            openSynthesis() {
                this.add.rectangle(600, 400, 1200, 800, 0x000000, 0.8);
                this.add.rectangle(600, 400, 900, 650, 0x1a1a2e);
                
                this.add.text(600, 100, 'ğŸ”® ì•„ì´í…œ í•©ì„±', {
                    fontSize: '28px',
                    fill: '#fff',
                    padding: { top: 7 }
                }).setOrigin(0.5);

                this.add.text(600, 150, 'ê°™ì€ ì¢…ë¥˜ 5ê°œë¥¼ í•©ì„±í•˜ì—¬ ìƒìœ„ ì•„ì´í…œ íšë“! (ì„±ê³µë¥  60%)', {
                    fontSize: '16px',
                    fill: '#aaa',
                    padding: { top: 4 }
                }).setOrigin(0.5);

                // í•©ì„± ê°€ëŠ¥í•œ ì•„ì´í…œ ì°¾ê¸°
                const itemCounts = {};
                gameData.inventory.forEach(item => {
                    const key = `sword_${item.tier}`;
                    itemCounts[key] = (itemCounts[key] || 0) + 1;
                });

                let y = 220;
                let hasItems = false;
                
                Object.keys(itemCounts).forEach(key => {
                    const tier = parseInt(key.split('_')[1]);
                    const count = itemCounts[key];
                    const itemData = ITEM_STATS.sword[tier - 1];

                    if (count >= 5 && tier < 5) {
                        hasItems = true;
                        const btn = this.add.rectangle(600, y, 500, 50, itemData.color)
                            .setInteractive({ useHandCursor: true });
                        
                        this.add.text(600, y, `${itemData.name} x${count} â†’ í•©ì„±í•˜ê¸°`, {
                            fontSize: '18px',
                            fill: '#fff'
                        }).setOrigin(0.5);

                        btn.on('pointerdown', () => {
                            this.synthesize(tier);
                        });

                        y += 60;
                    }
                });

                if (!hasItems) {
                    this.add.text(600, 350, 'í•©ì„± ê°€ëŠ¥í•œ ì•„ì´í…œì´ ì—†ìŠµë‹ˆë‹¤\n(ê°™ì€ ì¢…ë¥˜ 5ê°œ í•„ìš”)', {
                        fontSize: '20px',
                        fill: '#ff8888',
                        align: 'center'
                    }).setOrigin(0.5);
                }

                // ë‹«ê¸° ë²„íŠ¼
                const closeBtn = this.add.rectangle(600, 680, 150, 40, 0xff0000)
                    .setInteractive({ useHandCursor: true });
                this.add.text(600, 680, 'ë‹«ê¸°', {
                    fontSize: '20px',
                    fill: '#fff'
                }).setOrigin(0.5);

                closeBtn.on('pointerdown', () => {
                    this.scene.restart();
                });
            }

            synthesize(tier) {
                let removed = 0;
                gameData.inventory = gameData.inventory.filter(item => {
                    if (item.tier === tier && removed < 5) {
                        removed++;
                        return false;
                    }
                    return true;
                });

                if (Math.random() < 0.6) {
                    gameData.inventory.push({ type: 'sword', tier: tier + 1 });
                    alert(`âœ¨ í•©ì„± ì„±ê³µ! ${ITEM_STATS.sword[tier].name} íšë“!`);
                } else {
                    alert('ğŸ’¥ í•©ì„± ì‹¤íŒ¨... ì•„ì´í…œì´ ì†Œë©¸í–ˆìŠµë‹ˆë‹¤');
                }

                saveGameData();
                this.scene.restart();
            }
        }

        // ========================================
        // í”Œë ˆì´ í™”ë©´ Scene
        // ========================================

        class PlayScene extends Phaser.Scene {
            constructor() {
                super({ key: 'PlayScene' });
            }

            create() {
                this.add.rectangle(600, 400, 1200, 800, 0x2a2a3e);

                const stats = this.calculateStats();
                
                this.playerMaxHp = 100;
                this.playerHp = 100;
                this.playerPower = stats.power;

                // ê²Œì„ ì‹œì‘ ì‹œ ì„ì‹œ ì¸ë²¤í† ë¦¬ ì´ˆê¸°í™”
                this.sessionInventory = [];

                this.player = this.add.circle(600, 400, 20, 0x00aaff);
                this.physics.add.existing(this.player);
                this.player.body.setCollideWorldBounds(true);
                this.player.body.setCircle(20);
                this.player.body.setBounce(0);

                // ì¹¼ ìƒì„±
                this.sword = this.add.rectangle(0, 0, 40, 10, 0xffff00);
                this.sword.visible = false;
                
                // ì¹¼ ìƒ‰ìƒ ì—…ë°ì´íŠ¸
                this.updateSwordColor();

                // ê²€ ì¿¨ë‹¤ìš´ ì¶”ê°€
                this.swordCooldown = 0;
                this.swordCooldownMax = 1000; // 1ì´ˆ

                this.cursors = this.input.keyboard.createCursorKeys();
                
                // WASD í‚¤ ì¶”ê°€
                this.wasd = this.input.keyboard.addKeys({
                    up: Phaser.Input.Keyboard.KeyCodes.W,
                    down: Phaser.Input.Keyboard.KeyCodes.S,
                    left: Phaser.Input.Keyboard.KeyCodes.A,
                    right: Phaser.Input.Keyboard.KeyCodes.D
                });
                
                this.input.on('pointerdown', (pointer) => {
                    this.swingSword(pointer.x, pointer.y);
                });

                this.wave = 1;
                this.monstersKilled = 0;
                this.monsters = this.physics.add.group();
                this.droppedItems = this.physics.add.group();

                this.waveText = this.add.text(600, 20, `Wave ${this.wave}`, {
                    fontSize: '28px',
                    fill: '#fff',
                    padding: { top: 7 }
                }).setOrigin(0.5);

                this.hpText = this.add.text(20, 20, `HP: ${this.playerHp}/${this.playerMaxHp}`, {
                    fontSize: '20px',
                    fill: '#00ff00',
                    padding: { top: 5 }
                });

                this.statsText = this.add.text(20, 50, `ê³µê²©ë ¥: ${this.playerPower}`, {
                    fontSize: '16px',
                    fill: '#ffff00',
                    padding: { top: 4 }
                });

                this.cooldownText = this.add.text(20, 80, `ì¿¨ë‹¤ìš´: ì¤€ë¹„`, {
                    fontSize: '16px',
                    fill: '#00ff00',
                    padding: { top: 4 }
                });

                this.spawnWave();

                this.physics.add.collider(
                    this.player,
                    this.monsters,
                    this.onPlayerMonsterCollide,
                    null,
                    this
                );

                this.physics.add.overlap(
                    this.player,
                    this.droppedItems,
                    this.collectItem,
                    null,
                    this
                );

                this.physics.add.collider(this.monsters, this.monsters);

                // ëª¨ë°”ì¼ ì»¨íŠ¸ë¡¤ëŸ¬ ìƒì„±
                if (gameData.showController) {
                    this.createMobileController();
                }
            }

            createMobileController() {
                // ë°©í–¥ ë²„íŠ¼
                const btnSize = 60;
                const btnPadding = 70;
                const baseX = 100;
                const baseY = 650;

                // ìœ„
                this.upBtn = this.add.rectangle(baseX, baseY - btnPadding, btnSize, btnSize, 0x444444, 0.7)
                    .setInteractive()
                    .setScrollFactor(0);
                this.add.text(baseX, baseY - btnPadding, 'â–²', {
                    fontSize: '24px',
                    fill: '#fff'
                }).setOrigin(0.5).setScrollFactor(0);

                // ì•„ë˜
                this.downBtn = this.add.rectangle(baseX, baseY + btnPadding, btnSize, btnSize, 0x444444, 0.7)
                    .setInteractive()
                    .setScrollFactor(0);
                this.add.text(baseX, baseY + btnPadding, 'â–¼', {
                    fontSize: '24px',
                    fill: '#fff'
                }).setOrigin(0.5).setScrollFactor(0);

                // ì™¼ìª½
                this.leftBtn = this.add.rectangle(baseX - btnPadding, baseY, btnSize, btnSize, 0x444444, 0.7)
                    .setInteractive()
                    .setScrollFactor(0);
                this.add.text(baseX - btnPadding, baseY, 'â—€', {
                    fontSize: '24px',
                    fill: '#fff'
                }).setOrigin(0.5).setScrollFactor(0);

                // ì˜¤ë¥¸ìª½
                this.rightBtn = this.add.rectangle(baseX + btnPadding, baseY, btnSize, btnSize, 0x444444, 0.7)
                    .setInteractive()
                    .setScrollFactor(0);
                this.add.text(baseX + btnPadding, baseY, 'â–¶', {
                    fontSize: '24px',
                    fill: '#fff'
                }).setOrigin(0.5).setScrollFactor(0);

                // ê³µê²© ë²„íŠ¼
                this.attackBtn = this.add.circle(1100, 680, 50, 0xff0000, 0.7)
                    .setInteractive()
                    .setScrollFactor(0);
                this.add.text(1100, 680, 'âš”', {
                    fontSize: '32px',
                    fill: '#fff'
                }).setOrigin(0.5).setScrollFactor(0);

                this.attackBtn.on('pointerdown', () => {
                    // í”Œë ˆì´ì–´ ì•ìª½ìœ¼ë¡œ ê³µê²©
                    const angle = this.player.body.velocity.angle() || 0;
                    const targetX = this.player.x + Math.cos(angle) * 100;
                    const targetY = this.player.y + Math.sin(angle) * 100;
                    this.swingSword(targetX, targetY);
                });

                // ë°©í–¥ ì…ë ¥ ìƒíƒœ
                this.mobileInput = {
                    up: false,
                    down: false,
                    left: false,
                    right: false
                };

                this.upBtn.on('pointerdown', () => { this.mobileInput.up = true; });
                this.upBtn.on('pointerup', () => { this.mobileInput.up = false; });
                this.upBtn.on('pointerout', () => { this.mobileInput.up = false; });

                this.downBtn.on('pointerdown', () => { this.mobileInput.down = true; });
                this.downBtn.on('pointerup', () => { this.mobileInput.down = false; });
                this.downBtn.on('pointerout', () => { this.mobileInput.down = false; });

                this.leftBtn.on('pointerdown', () => { this.mobileInput.left = true; });
                this.leftBtn.on('pointerup', () => { this.mobileInput.left = false; });
                this.leftBtn.on('pointerout', () => { this.mobileInput.left = false; });

                this.rightBtn.on('pointerdown', () => { this.mobileInput.right = true; });
                this.rightBtn.on('pointerup', () => { this.mobileInput.right = false; });
                this.rightBtn.on('pointerout', () => { this.mobileInput.right = false; });
            }

            calculateStats() {
                let power = 10;

                if (gameData.equipped.sword) {
                    power += ITEM_STATS.sword[gameData.equipped.sword - 1].power;
                }

                return { power };
            }

            updateSwordColor() {
                if (gameData.equipped.sword) {
                    const swordColor = ITEM_STATS.sword[gameData.equipped.sword - 1].color;
                    this.sword.setFillStyle(swordColor);
                } else {
                    this.sword.setFillStyle(0xffff00); // ê¸°ë³¸ ë…¸ë€ìƒ‰
                }
            }

            update(time, delta) {
                const speed = 200;
                this.player.body.setVelocity(0);

                // í‚¤ë³´ë“œ ì…ë ¥ (ë°©í–¥í‚¤ + WASD)
                if (this.cursors.left.isDown || this.wasd.left.isDown) {
                    this.player.body.setVelocityX(-speed);
                } else if (this.cursors.right.isDown || this.wasd.right.isDown) {
                    this.player.body.setVelocityX(speed);
                }

                if (this.cursors.up.isDown || this.wasd.up.isDown) {
                    this.player.body.setVelocityY(-speed);
                } else if (this.cursors.down.isDown || this.wasd.down.isDown) {
                    this.player.body.setVelocityY(speed);
                }

                // ëª¨ë°”ì¼ ì…ë ¥
                if (gameData.showController && this.mobileInput) {
                    if (this.mobileInput.left) {
                        this.player.body.setVelocityX(-speed);
                    } else if (this.mobileInput.right) {
                        this.player.body.setVelocityX(speed);
                    }

                    if (this.mobileInput.up) {
                        this.player.body.setVelocityY(-speed);
                    } else if (this.mobileInput.down) {
                        this.player.body.setVelocityY(speed);
                    }
                }

                // ì¿¨ë‹¤ìš´ ì—…ë°ì´íŠ¸
                if (this.swordCooldown > 0) {
                    this.swordCooldown -= delta;
                    const cooldownPercent = Math.ceil((this.swordCooldown / this.swordCooldownMax) * 100);
                    this.cooldownText.setText(`ì¿¨ë‹¤ìš´: ${Math.max(0, cooldownPercent)}%`);
                    this.cooldownText.setColor('#ff0000');
                } else {
                    this.cooldownText.setText(`ì¿¨ë‹¤ìš´: ì¤€ë¹„`);
                    this.cooldownText.setColor('#00ff00');
                }

                // ëª¬ìŠ¤í„° AI: ì¼ì • ë²”ìœ„ ì•ˆì— ìˆê±°ë‚˜ ì–´ê·¸ë¡œ ìƒíƒœì¼ ë•Œë§Œ ì«“ì•„ê°
                this.monsters.children.entries.forEach(monster => {
                    if (monster.active) {
                        // í”Œë ˆì´ì–´ì™€ì˜ ê±°ë¦¬ ê³„ì‚°
                        const distance = Phaser.Math.Distance.Between(
                            this.player.x, 
                            this.player.y, 
                            monster.x, 
                            monster.y
                        );
                        
                        // í”Œë ˆì´ì–´ ë°˜ê²½ì˜ 17ë°° ë²”ìœ„ = 20 * 17 = 340
                        const aggroRange = 170;
                        
                        // ë²”ìœ„ ì•ˆì— ìˆìœ¼ë©´ ì–´ê·¸ë¡œ í™œì„±í™”
                        if (distance <= aggroRange) {
                            monster.aggro = true;
                        }
                        
                        // ì–´ê·¸ë¡œ ìƒíƒœì¼ ë•Œë§Œ ì«“ì•„ê°
                        if (monster.aggro) {
                            this.physics.moveToObject(monster, this.player, 50 + this.wave * 5);
                        }
                    }
                    
                    if (monster.hpBar) {
                        monster.hpBar.x = monster.x;
                        monster.hpBar.y = monster.y - 25;
                    }
                });
            }

            spawnWave() {
                this.monstersKilled = 0;
                const monstersToSpawn = 5 + this.wave * 2;
                this.totalMonstersInWave = monstersToSpawn;

                for (let i = 0; i < monstersToSpawn; i++) {
                    this.time.delayedCall(i * 500, () => {
                        this.spawnMonster();
                    });
                }
            }

            spawnMonster() {
                const x = Phaser.Math.Between(50, 1150);
                const y = Phaser.Math.Between(50, 750);
                
                // ì›¨ì´ë¸Œì— ë”°ë¼ ëª¬ìŠ¤í„° ë“±ê¸‰ ê²°ì • (ìµœì†Œ 1, ìµœëŒ€ 5)
                const tier = Math.min(Math.ceil(this.wave / 3), 5);
                const monsterData = MONSTER_STATS[tier - 1];
                
                const monster = this.add.circle(x, y, 15, monsterData.color);
                this.physics.add.existing(monster);
                monster.body.setCircle(15);
                monster.body.setBounce(0);
                monster.body.setImmovable(false);

                monster.hp = monsterData.hp;
                monster.maxHp = monsterData.hp;
                monster.power = monsterData.power;
                monster.tier = tier;
                monster.lastHitTime = 0;
                monster.aggro = false; // ì²˜ìŒì—ëŠ” ì–´ê·¸ë¡œ ì—†ìŒ

                this.monsters.add(monster);

                monster.hpBar = this.add.rectangle(x, y - 25, 30, 4, 0x00ff00);
            }

            swingSword(targetX, targetY) {
                if (this.swordCooldown > 0) {
                    return;
                }

                this.swordCooldown = this.swordCooldownMax;

                // ì¹¼ ìƒ‰ìƒ ì—…ë°ì´íŠ¸
                this.updateSwordColor();
                
                this.sword.visible = true;
                const angle = Phaser.Math.Angle.Between(this.player.x, this.player.y, targetX, targetY);
                
                this.sword.x = this.player.x + Math.cos(angle) * 40;
                this.sword.y = this.player.y + Math.sin(angle) * 40;
                this.sword.rotation = angle;

                this.monsters.children.entries.forEach(monster => {
                    if (monster.active) {
                        const dist = Phaser.Math.Distance.Between(this.sword.x, this.sword.y, monster.x, monster.y);
                        if (dist < 40) {
                            this.damageMonster(monster);
                        }
                    }
                });

                this.time.delayedCall(100, () => {
                    this.sword.visible = false;
                });
            }

            damageMonster(monster) {
                monster.hp -= this.playerPower;
                monster.aggro = true; // ê³µê²©ë°›ìœ¼ë©´ ì–´ê·¸ë¡œ í™œì„±í™”
                
                const hpPercent = monster.hp / monster.maxHp;
                monster.hpBar.width = 30 * hpPercent;
                monster.hpBar.fillColor = hpPercent > 0.5 ? 0x00ff00 : hpPercent > 0.25 ? 0xffff00 : 0xff0000;

                if (monster.hp <= 0) {
                    this.killMonster(monster);
                }
            }

            killMonster(monster) {
                // ì•„ì´í…œ ë“œë (50% í™•ë¥ )
                if (Math.random() < 0.5) {
                    this.dropItem(monster.x, monster.y, monster.tier);
                }

                if (monster.hpBar) {
                    monster.hpBar.destroy();
                }
                monster.destroy();

                this.monstersKilled++;
                
                if (this.monstersKilled >= this.totalMonstersInWave) {
                    this.wave++;
                    this.waveText.setText(`Wave ${this.wave}`);
                    
                    if (this.wave > gameData.highestWave) {
                        gameData.highestWave = this.wave;
                    }

                    this.time.delayedCall(2000, () => {
                        this.spawnWave();
                    });
                }
            }

            dropItem(x, y, tier) {
                const itemData = ITEM_STATS.sword[tier - 1];
                
                const item = this.add.rectangle(x, y, 20, 6, itemData.color);
                item.setRotation(0.785);
                this.physics.add.existing(item);
                item.body.setSize(20, 6);
                
                item.itemTier = tier;
                item.itemType = 'sword';
                
                this.tweens.add({
                    targets: item,
                    scale: { from: 1, to: 1.2 },
                    duration: 500,
                    yoyo: true,
                    repeat: -1
                });

                this.tweens.add({
                    targets: item,
                    rotation: item.rotation + Math.PI * 2,
                    duration: 2000,
                    repeat: -1
                });

                this.droppedItems.add(item);
            }

            collectItem(player, item) {
                // ì„¸ì…˜ ì¸ë²¤í† ë¦¬ì—ë§Œ ì¶”ê°€ (ì €ì¥í•˜ì§€ ì•ŠìŒ)
                this.sessionInventory.push({ 
                    type: item.itemType, 
                    tier: item.itemTier 
                });
                
                const itemData = ITEM_STATS.sword[item.itemTier - 1];
                const text = this.add.text(item.x, item.y - 30, `+${itemData.name}`, {
                    fontSize: '18px',
                    fill: '#' + itemData.color.toString(16).padStart(6, '0'),
                    fontStyle: 'bold'
                }).setOrigin(0.5);

                this.tweens.add({
                    targets: text,
                    y: text.y - 50,
                    alpha: 0,
                    duration: 1000,
                    onComplete: () => {
                        text.destroy();
                    }
                });

                item.destroy();
            }

            onPlayerMonsterCollide(player, monster) {
                const now = this.time.now;

                if (now - monster.lastHitTime < 100) return;

                monster.lastHitTime = now;
                monster.aggro = true; // ì¶©ëŒ ì‹œì—ë„ ì–´ê·¸ë¡œ í™œì„±í™”
                this.hitPlayer(monster);
            }

            hitPlayer(monster) {
                const damage = monster.power;
                this.playerHp -= damage;
                this.hpText.setText(`HP: ${this.playerHp}/${this.playerMaxHp}`);
                this.hpText.setColor(this.playerHp > this.playerMaxHp * 0.3 ? '#00ff00' : '#ff0000');

                this.cameras.main.shake(100, 0.01);

                if (this.playerHp <= 0) {
                    // ê²Œì„ ì¢…ë£Œ ì‹œì—ë§Œ ì„¸ì…˜ ì¸ë²¤í† ë¦¬ë¥¼ ì‹¤ì œ ì¸ë²¤í† ë¦¬ì— ì¶”ê°€
                    gameData.inventory = gameData.inventory.concat(this.sessionInventory);
                    saveGameData();
                    this.scene.start('GameOverScene', { wave: this.wave, itemsCollected: this.sessionInventory.length });
                }
            }
        }

        // ========================================
        // ê²Œì„ ì˜¤ë²„ Scene
        // ========================================

        class GameOverScene extends Phaser.Scene {
            constructor() {
                super({ key: 'GameOverScene' });
            }

            init(data) {
                this.finalWave = data.wave;
                this.itemsCollected = data.itemsCollected || 0;
            }

            create() {
                this.add.rectangle(600, 400, 1200, 800, 0x000000);

                this.add.text(600, 250, 'ğŸ’€ ê²Œì„ ì˜¤ë²„ ğŸ’€', {
                    fontSize: '56px',
                    fill: '#ff0000'
                }).setOrigin(0.5);

                this.add.text(600, 370, `ë„ë‹¬ ì›¨ì´ë¸Œ: ${this.finalWave}`, {
                    fontSize: '28px',
                    fill: '#fff'
                }).setOrigin(0.5);

                this.add.text(600, 430, `íšë“ ì•„ì´í…œ: ${this.itemsCollected}ê°œ`, {
                    fontSize: '24px',
                    fill: '#ffaa00'
                }).setOrigin(0.5);

                const btn = this.add.rectangle(600, 530, 300, 70, 0x00ff00)
                    .setInteractive({ useHandCursor: true });
                
                this.add.text(600, 530, 'ë©”ì¸ í™”ë©´ìœ¼ë¡œ', {
                    fontSize: '28px',
                    fill: '#000'
                }).setOrigin(0.5);

                btn.on('pointerdown', () => {
                    this.scene.start('MainScene');
                });
            }
        }

        // ========================================
        // Phaser ê²Œì„ ì„¤ì •
        // ========================================

        const config = {
            type: Phaser.AUTO,
            width: 1200,
            height: 800,
            parent: 'game-container',
            physics: {
                default: 'arcade',
                arcade: {
                    gravity: { y: 0 },
                    debug: false
                }
            },
            scene: [MainScene, PlayScene, GameOverScene]
        };

        const game = new Phaser.Game(config);
    </script>
</body>
</html>
